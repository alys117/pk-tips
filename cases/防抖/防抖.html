<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>

  <button onclick="debounce(function(...args) {
  console.log('click', this.obj.tip)
  return 123
}, 1000,false)()">防抖</button> <!-- 直接写在onclick上不可以，还不知道为什么，和闭包有什么关系吗？？ -->
  <button id="fd2" data-attr="smile">防抖2</button> <!--使用addEventListener可以 -->
</body>
<script>
  let count = 0
  function debounce (func, wait, immediate) {
    let timeout, args, context, timestamp, result

    const later = function () {
      console.log('later 被调用');
      // 据上一次触发时间间隔
      const last = +new Date() - timestamp

      // 上次被包装函数被调用时间间隔 last 小于设定时间间隔 wait
      if (last < wait && last > 0) {
        console.log('延迟执行');
        timeout = setTimeout(later, wait - last)
      } else {
        timeout = null
        // 如果设定为immediate===true，因为开始边界已经调用过了此处无需调用
        if (!immediate) {
          console.log(context, args, 1);
          result = func.apply(context, args)
          if (!timeout) {
            console.log('timeout', timeout);
            context = args = null
          } else {
            console.log('timeout', timeout);
          }
        }
      }
    }
    return function (...args) {
      console.log('click 被调用');
      context = this
      timestamp = +new Date()
      const callNow = immediate && !timeout
      // 如果延时不存在，重新设定延时
      if (!timeout) timeout = setTimeout(later, wait)
      if (callNow) {
        console.log(context, args, 2);
        result = func.apply(context, args)
        context = args = null
      }
      console.log(result, '目标函数返回结果');
      return result
    }
  }
  var obj = { tip: 'shooting star' }
  document.getElementById('fd2').addEventListener('click', debounce(function (...args) {
    console.log('click', this.dataset)
    return 'target function return ' + ++count
  }, 1000, false)) // 如果第三个参数immediate传false，返回的 target function return 其实是上一次的结果
</script>

</html>